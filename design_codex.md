# 作業音リアルタイム生成プロトタイプ設計（Web + FastAPI）

## 1. 目的
大規模モデルを用いて高品質な 60 秒音声を連続生成し、Web アプリとして途切れにくく再生する最小プロトタイプを構築する。

## 2. スコープ
### 2.1 対象
- HTML / CSS / JavaScript によるシンプルな Web フロントエンドを実装する。
- FastAPI によるバックエンドサーバーを実装する。
- 60 秒の高品質音声を 1 本ずつ逐次生成する。
- ACE-Step 1.5 の高品質構成を使用し、LM は `acestep-5Hz-lm-4B` を優先する。
- 生成済みの古いデータは必要区間を除き保持しない。
- 次セグメント生成時に、直前セグメントの末尾 15 秒をインペインティング入力として利用する。
- フロントエンドとサーバーをステータス API で厳密に同期させる。
- サーバーからローカル再生環境への WAV ダウンロードに 5〜10 秒の遅延がある前提で設計する。
- ブラウザ開発者ツールで追跡できるよう、`console.log` を高頻度で出力する。

### 2.2 非対象（本プロトタイプでは実施しない）
- 複数ユーザー同時利用
- 認証・課金・管理画面
- 分散ジョブキュー
- 本格的な監視基盤

## 3. モデル方針（ACE-Step 1.5）
- LM は `acestep-5Hz-lm-4B` を第一候補とする（高品質優先）。
- 4B が未導入、または GPU/VRAM 条件で安定運用できない場合は `acestep-5Hz-lm-1.7B` へフォールバックする。
- LM を有効にするため `thinking=true` を必須とする。
- DiT モデルは品質優先で `acestep-v15-sft` を第一候補とし、推論速度を優先する場合は `acestep-v15-turbo` を使用する。
- API パラメータは少なくとも以下を指定する。
  - `lm_model_path`: `acestep-5Hz-lm-4B`（フォールバック時は `acestep-5Hz-lm-1.7B`）
  - `lm_backend`: `vllm`
  - `thinking`: `true`
  - `model`: `acestep-v15-sft` または `acestep-v15-turbo`
- モデル導入時は `uv run acestep-download --model acestep-5Hz-lm-4B` で取得し、起動時に利用可能であることを確認する。

## 4. アーキテクチャ
### 4.1 コンポーネント
1. **Web Frontend（HTML/CSS/JS）**
- 生成開始・停止の操作を提供する。
- `idle` / `generating` / `downloading` / `playing` / `error` の状態を表示する。
- 定期ポーリングでサーバー状態を取得する。
- API 呼び出し・状態遷移・再生イベントを `console.log` で記録する。

2. **FastAPI Server**
- セッション開始・停止 API を提供する。
- 大規模モデル推論を実行し、最新セグメント WAV を一時保存する。
- 直前セグメント末尾 15 秒を切り出して次生成のインペインティング入力を作成する。
- 最新 WAV 配信 API とステータス API を提供する。
- 受け渡し済みの不要データを削除する。

3. **Inference Worker（単一プロセス）**
- 60 秒セグメントを逐次生成する。
- セグメント N+1 はセグメント N の末尾 15 秒を条件として生成する。
- 同時実行は行わず、常に 1 ジョブずつ処理する。

### 4.2 フロントエンド詳細仕様
- 画面に `prompt` 入力フォーム、`Play` ボタン、`Stop` ボタン、状態表示を配置する。
- ユーザーが `Play` を押した時点で初回セグメント生成を開始する（事前生成はしない）。
- `Play` 押下時にフォーム値をそのまま `POST /session/start` のリクエストへ含め、初回生成条件として即時反映する。
- 生成ループ中に prompt を更新した場合、次セグメント生成から新しい値を適用する（適用タイミングを UI に表示する）。
- prompt 未入力時はデフォルト prompt を使用する。
  - デフォルト値: `instrumental ambient focus music, smooth continuous texture, no vocals, stable rhythm`
- 再生は Web Audio API を使用し、現在セグメント末尾と次セグメント先頭の重複 15 秒をクロスフェードで接続する。
- 重複区間は単純連結しない。クロスフェードにより「同一内容の二重再生感」を抑える。
- 基本クロスフェード長は 3〜5 秒とし、必要に応じて設定可能にする。

### 4.3 データフロー
1. ユーザーが `Play` を押し、フロントエンドが prompt フォーム値付きで `POST /session/start` を実行する。
2. サーバーが最初の 60 秒音声を生成する。
3. フロントエンドが `GET /audio/current.wav` で WAV を取得する。
4. 現在セグメントの再生中に、サーバーが次セグメントを準備する。
5. 再生終了の 10〜15 秒前を目安に、フロントエンドが次セグメント WAV の先行ダウンロードを開始する。
6. サーバーが現在セグメント末尾 15 秒を抽出する。
7. サーバーが 60 秒の `seed` 音声を作る（先頭15秒=抽出音声、残り45秒=無音）。
8. サーバーが `task_type=repaint` で次セグメントを生成する（`repainting_start=15.0`, `repainting_end=-1`）。
9. 生成時 prompt は「最新確定 prompt」を使用する（Play時入力、または更新後の次セグメント向け入力）。
10. 以降を繰り返す。
11. サーバーは不要になった古い成果物を削除する。

## 5. API 草案
- `POST /session/start`
  - 生成ループを開始する。
  - リクエストに `prompt` を含め、初回セグメントへ即時適用する。
- `POST /session/stop`
  - 生成ループを停止し、一時状態をクリアする。
- `GET /session/status`
  - 状態、`segment_index`、進行情報、エラー情報を返す。
- `GET /audio/current.wav`
  - 最新の再生可能 WAV を返す。
- `GET /health`
  - ヘルスチェック結果を返す。

### 5.1 生成リクエスト詳細（ACE-Step API 呼び出し）
- 初回セグメントは `task_type=text2music` で生成する。
- 2本目以降は `task_type=repaint` を使用し、`src_audio` に `seed` 音声を渡す。
- repaint 用の主要パラメータ:
  - `task_type`: `repaint`
  - `src_audio`: 先頭15秒に前セグメント末尾を埋めた 60 秒 `seed` 音声
  - `repainting_start`: `15.0`
  - `repainting_end`: `-1`
  - `thinking`: `true`
  - `lm_backend`: `vllm`
  - `lm_model_path`: `acestep-5Hz-lm-4B`（フォールバック時 `1.7B`）
  - `model`: `acestep-v15-sft` または `acestep-v15-turbo`
  - `caption`: 最新確定 prompt

## 6. 同期ルール
- フロントエンドは WAV 取得前に `GET /session/status` を確認する。
- サーバーは単調増加する `segment_index` を返す。
- フロントエンドは古い `segment_index` の WAV を破棄する。
- 5〜10 秒のダウンロード遅延を吸収するため、次セグメントは現在再生の終了前に先行ダウンロードする。
- 先行ダウンロード開始条件は「再生残り時間 <= 15 秒」を基本とし、実測遅延が大きい環境では 20 秒まで拡張可能にする。
- 次セグメントのダウンロード完了が確認できるまで再生切り替えを行わない。
- 再生切り替え時は重複 15 秒区間をクロスフェード接続し、同一音声の重複感を抑制する。

## 7. デバッグ・運用要件
### 7.1 フロントエンドログ（必須）
`console.log` / `console.error` で以下を記録する。
- API リクエスト開始・終了時刻
- 状態遷移
- WAV ダウンロード開始・終了と実測遅延
- 再生開始・終了
- エラー詳細

### 7.2 バックエンドログ
セグメント単位で以下を記録する。
- 生成開始・終了時刻
- 参照したインペインティング元セグメント
- WAV サイズと配信時間
- 古いデータ削除の実行結果

## 8. 前提性能
- 単一セッション運用である。
- 並列生成は行わず逐次生成のみとする。
- WAV 転送遅延 5〜10 秒が発生してもセッション継続できる設計とする。

## 9. Definition of Done
- フロントエンド（HTML/CSS/JS）と FastAPI が接続される。
- 60 秒セグメントの高品質生成が動作する。
- 次セグメント生成で末尾 15 秒インペインティングが適用される。
- 不要な古いデータが保持されない。
- フロントエンドとサーバーの状態同期が維持される。
- 5〜10 秒の WAV ダウンロード遅延下でも処理が破綻しない。
- ブラウザログで主要な障害原因を追跡できる。

## 10. 実装ステップ
1. 事前準備
- `ACE-Step-1.5` で依存を同期する（`uv sync`）。
- モデルを準備する（`acestep-5Hz-lm-4B`、必要に応じて `1.7B` フォールバック）。
- `acestep-api` を起動し、`/health` と `/v1/models` の疎通を確認する。

2. FastAPI プロトタイプ骨組みを作成
- `POST /session/start`、`POST /session/stop`、`GET /session/status`、`GET /audio/current.wav` を実装する。
- 単一セッション状態（`segment_index`、状態、最新 prompt、再生中フラグ）をメモリ管理する。
- 旧セッションの一時ファイルをクリアする処理を実装する。

3. 初回生成（text2music）を実装
- `Play` 時に受け取った prompt を確定し、未入力時はデフォルト prompt を採用する。
- `task_type=text2music` で `release_task` を呼び、`query_result` 完了後に WAV を取得可能状態にする。
- 生成メタ（開始時刻、終了時刻、モデル、task_id）をログ出力する。

4. 継続生成（repaint）を実装
- 前セグメント末尾15秒を抽出し、60秒 `seed`（15秒コンテキスト + 45秒無音）を作成する。
- `task_type=repaint`、`repainting_start=15.0`、`repainting_end=-1` で次セグメント生成を実行する。
- 生成時は「最新確定 prompt」を適用し、prompt 更新は次セグメントから有効にする。

5. フロントエンド（純粋 HTML/JS）を実装
- prompt 入力、Play/Stop、状態表示、遅延表示の UI を作成する。
- `Play` で `/session/start` を呼び、フォーム値を即時送信する。
- `status` ポーリングを実装し、`segment_index` の更新を監視する。

6. 先行ダウンロードと再生制御を実装
- 現在再生の残り時間が 15 秒以下で次セグメントのダウンロードを開始する。
- 実測遅延に応じて先行開始閾値を 20 秒まで拡張可能にする。
- 未完了ダウンロード時は再生切り替えを待機し、途切れを回避する。

7. クロスフェードを実装
- Web Audio API（`AudioContext`、`AudioBufferSourceNode`、`GainNode`）で 2 セグメントを重ねる。
- 重複15秒区間のうち 3〜5 秒をクロスフェードして切り替える。
- 二重再生感が強い場合はフェード長とゲインカーブを調整する。

8. クリーンアップと監視
- 受け渡し済みの古い WAV、抽出15秒、seed ファイルを逐次削除する。
- クライアントは `console.log` / `console.error`、サーバーはセグメント単位ログを出力する。
- エラー時は状態を `error` に遷移し、再開可能な最小情報を保持する。

9. 検証
- 10分以上の連続再生で停止や破綻がないことを確認する。
- 5〜10秒のダウンロード遅延を人工的に入れても継続再生できることを確認する。
- prompt 未入力時デフォルト適用、更新時の次セグメント反映、4B→1.7B フォールバックを確認する。
